package com.jostens.dam.shared.properties;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.StringTokenizer;

import com.jostens.dam.shared.common.ExceptionHelper;
import com.jostens.dam.shared.folders.SharedFolderPath;

/**
 * Class that provides a access mechanism to MediaBin java code property files.
 * 
 * This class defines constants for the known property files.  Implementors of this object
 * must return one of those definitions as the property file name.
 */
public abstract class PropertyFile extends Properties
{
	// This attribute holds the full path to the property file.  This value should only be set
	// once and is either generated by looking at environment objects or the value can
	// be provided to a constructor
	protected String propertyFilePath = null;
	
	// All lines found in the file will be added to this Map (including comments).  With this, the
	// full contents of the file in order are in place.  This enables the property file to
	// be written out in exact order if desired instead of the not predictable order Properties provides.
	protected Map<Object, Object> properties = new LinkedHashMap<Object, Object>();
	
	// Define the names of property files that can be used by extending classes
	protected String EMAIL_PROPERTIES = "Email.properties";
	protected String METRICS_PROPERTIES = "Metrics.properties";
	protected String CONNECTION_PROPERTIES = "Connection.properties";
	protected String REINDEX_PROPERTIES = "Reindex.properties";
	protected String CUSTOMER_PROPERTIES = "Customer.properties";
	protected String RUNTIME_PROPERTIES = "Runtime.properties";
	protected String MARKETING_PROPERTIES = "Marketing.properties";
	protected String CUSTOMER_SYNC_PROPERTIES = "CustomerProfileSync.properties";
	protected String LOCKED_PARTS_PROPERTIES = "LockedParts.properties";
	protected String HOT_FOLDER_PROPERTIES = "HotFolders.properties";
	protected String REVISION_CLEANUP_PROPERTIES = "RevisionCleanup.properties";
	protected String YEARBOOK_PROPERTIES = "Yearbook.properties";

	/**
	 * Constructor for loading property file with the specified full path
	 */
	public PropertyFile(String fullPath)
	{
		propertyFilePath = fullPath;
		loadPropertyValues();
	}
	/**
	 * Constructor for finding property file using environment objects
	 */
	public PropertyFile()
	{
		propertyFilePath = getFullPath();
		loadPropertyValues();
	}

	/**
	 * Load properties using the class attribute defining the property file path
	 */
	private void loadPropertyValues()
	{
		File file = new File(propertyFilePath);
		try
		{
			InputStream is = new FileInputStream(file);
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(new InputStreamReader(is));

			int commentCount = 1;	// Comment lines are kept in properties Map and need a unique key
									// which happens by incrementing this value
			int emptyCount = 1;		// Same for tracking empty lines
			String line = null;
			while ((line = br.readLine()) != null)
			{
				if (line.startsWith("#"))
				{
					String commentKey = "comment" + commentCount++;
					// Save the comment line then continue - but don't pass on to super class
					properties.put(commentKey, line);
					continue;
				}
				line = line.trim();
				if (line.length() == 0)
				{
					String emptyKey = "empty" + emptyCount++;
					// Save the comment line then continue - but don't pass on to super class
					properties.put(emptyKey, "");
					continue;
				}
				String key = null;
				String value = null;
				int i = line.indexOf("=");
				if (i != -1)
				{
					// Property row includes an =, so this is a key=value situation which is the normal property file
					key = line.substring(0, i);
					value = line.substring(i + 1);
					value = value.replaceAll("\\\\", "");
				}
				else
				{
					// This is where no = is found, so each row is the key and the value is empty.  This is like lockedParts.properties
					key = line;
					value = "";
				}
				// Remove any escape characters, preceded by a backslash
				properties.put(key, value);
				// For a real property, need to pass on to super class
				super.put(key, value);
			}
		 
			br.close();
			isr.close();
			is.close();

		}
		catch (IOException e)
		{
// WAS - July 2015 - Property file exceptions cannot log the exception to the file because a 
// property file is needed that could be causing the exception
//			ExceptionHelper.logExceptionToFile("PropertyFile (PropertyFile) File: " + getPropertyFileName() + " Path: " + fullPath, e);
			System.out.println("IOException while accessing property file for " + getPropertyFileName() + " at " + propertyFilePath + "\n" + e.getMessage());
		}
	}
	
	/**
	 * Return the path to the property file.  Classes that extend can over-ride if the property file is not in a default location
	 */
	protected String getFullPath()
	{
		return SharedFolderPath.getPropertyFilePath() + getPropertyFileName();
	}

	/**
	 * Store property values using functionality provided by Properties class
	 */
	public void storePropertyValues()
	{
		// Open the properties base object on the specified property file name
		String fullPath = propertyFilePath;

		File file = new File(fullPath);
		OutputStream os = null;

		try
		{
			os = new FileOutputStream(file);
			store(os, getPropertyComments());
			os.close();
		}
		catch (IOException e)
		{
			ExceptionHelper.logExceptionToFile("storePropertyValues (PropertyFile) File: " + getPropertyFileName() + " Path: " + fullPath, e);
			//System.out.println("IOException while accessing property file for " + getPropertyFileName() + " at " + fullPath + "\n" + e.getMessage());
		}
	}

	/**
	 * Overwrite and return any string that should be written as a comment at header of file.
	 * 
	 * Note that for the comments when written, the Properties object will add a # first so don't have
	 * one prior to the first comment.  After each new line, include a # to start the line.
	 */
	public String getPropertyComments()
	{
		return null;
	}

	public void reloadPropertyValues()
	{
		// Before loading properties always perform a clear to assure starting clean
		clear();

		loadPropertyValues();
	}
	
	public void clear()
	{
		super.clear();
		properties.clear();
	}
	
	public String toString()
	{
		return super.toString();
	}

	/**
	 * Put a property key/value pair into the local properties Map and base Properties object.  If the key already exists, then that value is replaced.
	 * If this is a new property, then it will be added at the end of the property list.
	 * 
	 * The value for the key is returned to caller which should match what was passed into the method
	 */
	public Object put(Object key, Object value)
	{
		properties.put(key, value);
		super.put(key, value);		// Add to the base Properties object
		
		Object retValue = properties.get(key);
		return retValue;
	}
	
	/**
	 * If being ran from a unit test allow the changing of a file name when saving the property file.  Having this option
	 * enables unit tests to have a starting file that doesn't change and unit tests can write out different versions so
	 * changes can be validated.
	 */
	public void changePropertyFileNameForTesting(String newFileName)
	{
		if (!SharedFolderPath.isUnitTest())
		{
			// Not in unit test mode, so don't allow a change of file name
			return;
		}
		int i = propertyFilePath.lastIndexOf("/");
		if (i == -1)
		{
			return;
		}
		propertyFilePath = propertyFilePath.substring(0, i+1) + newFileName;
	}

	/**
	 * Methods to help simplify access to properties
	 */
	protected List<String> getStringListProperty(String value)
	{
		List<String> returnList = new ArrayList<String>();
		String propertyValue = getProperty(value);
		if (propertyValue == null)
		{
			return returnList;
		}
		StringTokenizer st = new StringTokenizer(propertyValue, ",");
		while (st.hasMoreTokens())
		{
			String token = st.nextToken();
			returnList.add(token);
		}
		return returnList;
	}
	protected String getStringProperty(String propertyName)
	{
		return getProperty(propertyName);
	}
	protected boolean getBooleanProperty(String propertyName)
	{
		String value = getProperty(propertyName);
		if ("true".equalsIgnoreCase(value))
		{
			return true;
		}
		return false;
	}
	protected int getIntProperty(String propertyName)
	{
		String value = getProperty(propertyName);
		if (value == null)
		{
			return 0;
		}
		int intValue = Integer.parseInt(value);
		return intValue;
	}
	protected void setStringProperty(String propertyName, String propertyValue)
	{
		put(propertyName, propertyValue);
	}
	protected void setBooleanProperty(String propertyName, boolean propertyValue)
	{
		if (propertyValue)
		{
			put(propertyName, "true");
		}
		put(propertyName, "false");
	}
	protected void setIntProperty(String propertyName, int propertyValue)
	{
		put(propertyName, "" + propertyValue);
	}
	public abstract String getPropertyFileName();
}
